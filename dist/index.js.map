{"version":3,"sources":["../src/index.ts","../src/lib/scraper.ts"],"sourcesContent":["import { Client, iteratePaginatedAPI } from \"@notionhq/client\";\nimport { DatabaseObjectResponse } from \"@notionhq/client/build/src/api-endpoints\";\nimport { sanitizeEntry } from \"./lib/scraper\";\nimport * as path from \"path\";\n\n// @ts-ignore\nString.prototype.toCamelCase = function (this) {\n  let result = this\n    // Remove non-alphanumeric characters except spaces and apostrophes\n    .replace(/[^a-zA-Z0-9 ']/g, \"\")\n    // Split the string into words using space as a delimiter\n    .split(\" \")\n    // Capitalize the first letter of each word\n    .map(\n      (word: string) =>\n        word.charAt(0).toUpperCase() + word.slice(1).toLowerCase(),\n    )\n    .join(\"\")\n    // Handle strings that start with numbers by prefixing an underscore\n    .replace(/^(\\d)/, \"_$1\");\n\n  // Capitalize the first letter of the result, if it's a letter\n  return result.charAt(0).toUpperCase() + result.slice(1);\n};\n\ntype DatabaseMappings = { [key: string]: string };\n\ninterface QueryParams {\n  [key: string]: any;\n}\n\ninterface Entity {\n  [key: string]: any;\n}\n\ninterface ResultsMetadata {\n  page: number;\n  limit: number;\n  has_more: boolean;\n  next_cursor?: string | null;\n}\n\ninterface MetaParams {\n  page?: number;\n  limit?: number;\n}\n\ntype UUID = string;\n\ninterface NotionClientConfig {\n  parents?: UUID[];\n  mappings: DatabaseMappings;\n  token: string;\n}\n\nexport class NotionClient {\n  private readonly parents?: UUID[];\n  mappings!: DatabaseMappings;\n  readonly client!: Client;\n\n  constructor(config: NotionClientConfig) {\n    this.mappings = { ...this.mappings, ...config.mappings };\n    this.parents = config.parents;\n    this.client = new Client({\n      auth: config.token,\n    });\n  }\n\n  async init() {\n    if (this.parents?.length) {\n      let mappings = {};\n      for (const parent of this.parents) {\n        const dbs = await this._populateChildDBs(parent);\n        mappings = { ...mappings, ...dbs };\n      }\n      this.mappings = { ...this.mappings, ...mappings };\n    }\n  }\n\n  private async _dbQuery(\n    databaseId: string,\n    filter: any,\n    page_size: number = 1,\n    start_cursor: string | null,\n  ) {\n    return this.client.databases.query({\n      database_id: databaseId,\n      ...(filter ? { filter } : {}),\n      page_size,\n      ...(start_cursor ? { start_cursor } : {}),\n    });\n  }\n\n  private async _pageQuery(page_id: string) {\n    return this.client.pages.retrieve({ page_id });\n  }\n\n  private async _createQuery(\n    database_id: string,\n    properties: { [key: string]: any },\n  ) {\n    return this.client.pages.create({\n      parent: {\n        database_id,\n      },\n      properties,\n    });\n  }\n\n  private async _childrenQuery(block_id: string) {\n    return this.client.blocks.children.list({ block_id });\n  }\n\n  private async _populateChildDBs(page_id: string) {\n    const children = await this._childrenQuery(page_id);\n    const DBS = {};\n    for (const block of children.results) {\n      // @ts-ignore\n      if (block?.type !== \"child_database\") continue;\n      // @ts-ignore\n      DBS[block.child_database.title.toCamelCase()] = block.id;\n    }\n\n    return DBS;\n  }\n\n  async get(\n    alias: keyof DatabaseMappings,\n    query: QueryParams,\n    meta: MetaParams = { limit: 15, page: 1 },\n  ): Promise<\n    | {\n        results: Entity[];\n        meta: ResultsMetadata;\n      }\n    | any\n  > {\n    const databaseId = this.mappings[alias];\n    const pageSize = meta.limit || 15;\n    let currentPage = meta.page || 1;\n    let totalResults: string | any[] = [];\n    let has_more = false;\n    let next_cursor = null;\n\n    let response = await this._dbQuery(databaseId, query, pageSize, null);\n    while (\n      response.results.length > 0 &&\n      totalResults.length < pageSize * currentPage\n    ) {\n      totalResults = [...totalResults, ...response.results];\n      if (!response.has_more) {\n        break;\n      }\n      has_more = response.has_more ?? false;\n      next_cursor = response.next_cursor ?? undefined;\n      response = await this._dbQuery(\n        databaseId,\n        query,\n        pageSize,\n        response.next_cursor,\n      );\n    }\n\n    // Prepare the `meta` object\n    const metadata = {\n      page: currentPage,\n      limit: pageSize,\n      has_more,\n      next_cursor,\n    };\n\n    const pageResults = totalResults.slice(\n      pageSize * (currentPage - 1),\n      pageSize * currentPage,\n    );\n    const results = [];\n    for (const pageResult of pageResults) {\n      results.push(\n        await sanitizeEntry({ id: pageResult.id, ...pageResult.properties }),\n      );\n    }\n    return {\n      results,\n      meta: metadata,\n    };\n  }\n\n  async getOne(\n    alias: keyof DatabaseMappings,\n    query: QueryParams,\n  ): Promise<Entity | any> {\n    const databaseId = this.mappings[alias];\n    const response = await this._dbQuery(databaseId, query, 1, null);\n    if (!response.results.length) return null;\n    const firstResult = response.results[0];\n    return sanitizeEntry({\n      id: response.results[0].id,\n      ...(firstResult as DatabaseObjectResponse).properties,\n    });\n  }\n\n  async getOneById(id: string): Promise<Entity | any> {\n    const response = await this._pageQuery(id).catch((e) => null);\n    return response\n      ? sanitizeEntry({ id: response.id, ...(response as {properties: any}).properties })\n      : null;\n  }\n\n  async create(alias: keyof DatabaseMappings, properties: Entity) {\n    return this._createQuery(this.mappings[alias], properties);\n  }\n}\n","export const joinRichText = (richTextArray: any[], useWrappers = false) => {\n  return useWrappers\n    ? richTextArray\n        .map((entity) => {\n          let content = entity.text.content;\n\n          // Apply formatting based on annotations\n          if (entity.annotations.bold) {\n            content = `**${content}**`;\n          }\n          if (entity.annotations.italic) {\n            content = `*${content}*`;\n          }\n          if (entity.annotations.strikethrough) {\n            content = `~~${content}~~`;\n          }\n          if (entity.annotations.underline) {\n            content = `<u>${content}</u>`;\n          }\n          if (entity.annotations.code) {\n            content = `\\`${content}\\``;\n          }\n          if (entity.text.link) {\n            content = `[${content}](${entity.text.link})`;\n          }\n\n          return content;\n        })\n        .join(\"\")\n    : richTextArray.map((entity) => entity.plain_text).join(\"\");\n};\n\nexport const eternifyFile = async (url) => {\n  const res = await fetch(\n    `https://filepod.keepish.net?url=${encodeURIComponent(url)}`,\n    {\n      method: \"GET\",\n    },\n  ).then((r) => r.json());\n  return res.id;\n};\n\nexport const sanitizeEntry = async ({ id, ...entry }) => {\n  const sanitized = {\n    id,\n  };\n  for (const [field, value] of Object.entries(entry)) {\n    sanitized[field] = value.type ? value[value.type] : value;\n    if ([\"title\", \"rich_text\"].includes(value.type)) {\n      sanitized[field] = {\n        rich: joinRichText(sanitized[field], true),\n        plain: joinRichText(sanitized[field]),\n      };\n    }\n    if (Array.isArray(sanitized[field])) {\n      for (let i = 0; i < sanitized[field].length; i++) {\n        if (sanitized[field][i].type === \"file\") {\n          const newUrlRes = await eternifyFile(sanitized[field][i].file.url);\n          sanitized[field][i].file.url =\n            `https://filepod.keepish.net/${newUrlRes}`;\n        }\n      }\n    }\n  }\n  return sanitized;\n};\n"],"mappings":"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","names":[]}